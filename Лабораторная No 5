                                                                Лабораторная работа №5
                                                     Выполнил студент группы Бст 2201 Сиау.Эрнест


                                                                      Задание №1
                                                    Реализовать методы поиска подстроки в строке. 
                                            Добавить возможность ввода строки и подстроки с клавиатуры. 
                                                  Предусмотреть возможность существования пробела. 
                             Реализовать возможность выбора опции чувствительности или нечувствительности к регистру. 
Оценить время работы каждого алгоритма поиска и сравнить его со временем работы стандартной функции поиска, используемой в выбранном языке программирования.

       
Алгоритм Кнута-Морриса-Пратта :

# Префикс-функция O(m)
def prefix(string):
    pi = [0] * len(string) # формируем массив pi
    i, j = 1, 0
    while i < len(string):
        if string[j] == string[i]:
            i += 1
            j += 1
        else:
            if j == 0:
                pi[i] = 0
                i += 1
            else:
                j = pi[j-1]
    return pi

# Алгоритм Кнута-Морриса-Пратта О(m+n) n-строка, m-подстрока
def KMP(string, substring):
    # добавляться индексы вхождения подстроки в строку
    arr_index = []
    # индекс текущего символа в подстроке
    substr_index = 0

    p = prefix(substring)

    for i in range(len(string)):
        while substr_index > 0 and string[i] != substring[substr_index]:
            # поиск подстроки в строке с использованием предыдущих символов подстроки.
            substr_index = p[substr_index - 1]
        # равен ли текущий символ строки символу подстроки.
        if string[i] == substring[substr_index]:
            substr_index += 1
        # нашли вхождение подстроки в строку
        if substr_index == len(substring):
            # добавляем индекс начала вхождения и конца вхождения в список arr_index.
            arr_index.append((i - len(substring) + 1, i + 1))
            # Затем переменная k устанавливается в значение префикс-функции для substring[k-1].
            substr_index = p[substr_index - 1]

    return arr_index


Алгоритм Бойера-Мура:
def BM(string, substring):
    A = []
    T = preprocess(substring)
    # отслеживания текущей позиции в строке
    skip = 0
    # пока остаток строки после скип не будет меньше длины слова.
    while len(string) - skip >= len(substring):
        # если подстрока s[skip:skip + len(w)] равна слову substring
        if string[skip:skip + len(substring)] == substring:
           # добавляем кортеж с индексами начала и конца вхождения слова в список A.
            A.append((skip, skip + len(substring)))
        # увеличиваем значение переменной skip на величину, указанную в таблице смещений для символа, стоящего сразу после последнего символа текущей подстроки.
        skip += T[ord(string[skip + len(substring) - 1])]
    return A


Встроенный поиск:

def INBS(string, substring):
    A = []
    index = string.find(substring)
    while index != -1:
        A.append((index, index + len(substring)))
        index = string.find(substring, index + 1)
    return A

Вызов функций алгоритмов и сравнение по времени:

import timeit

string = input("Введите строку: ")
substring = input("Введите подстроку: ")
register = input("Выключить регистр? (Да/Нет) ")
space = input("Выключить пробелы? (Да/Нет) ")

if register == "Да":
    string = string.lower()
    substring = substring.lower()
if space == "Да":
    string = string.replace(" ", "")
print(f"Теперь строка выглядит: {string}, а подстрока: {substring}")



print("КМР")
starttime = timeit.default_timer()
print(KMP(string, substring))
endtime = timeit.default_timer()
print(endtime - starttime, "секунд")

print("BM")
starttime = timeit.default_timer()
print(BM(string, substring))
endtime = timeit.default_timer()
print(endtime - starttime, "секунд")

print("Встроенный поиск")
starttime = timeit.default_timer()
print(INBS(string, substring))
endtime = timeit.default_timer()
print(endtime - starttime, "секунд")


                                                                     Задание №2 :

                                Написать программу, определяющую, является ли данное расположение «решаемым», 
                                    то есть можно ли из него за конечное число шагов перейти к правильному. 
                         Если это возможно, то необходимо найти хотя бы одно решение - последовательность движений, 
                                            после которой числа будут расположены в правильном порядке.

                                            Входные данные: массив чисел, представляющий собой расстановку в
  Порядке «слева направо, сверху вниз». Число 0 обозначает пустое поле. Например, массив [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0]
                                                    представляет собой «решенную» позицию элементов.

                                               Выходные данные: если решения нет, то функция должна вернуть
  Пустой массив []. Если решение есть, то необходимо представить решение — для каждого шага записывается номер передвигаемого на данном шаге элемента.



N=4
# принимает пятнашку в виде двумерного списка и возвращает количество инверсий в списке.
def getInvCount(arr):
    arr1=[]
    # преобразует двумерный список в одномерный список, чтобы упростить процесс подсчета инверсий.
    for y in arr:
        for x in y:
            arr1.append(x)
    arr=arr1
    inv_count = 0
    # два вложенных цикла для сравнения каждой пары элементов в списке. 
    for i in range(N * N - 1):
        for j in range(i + 1,N * N):
            if (arr[j] and arr[i] and arr[i] > arr[j]):
                inv_count+=1
         
    # общее количество инверсий в списке. Инверсия - это пара чисел в последовательности, где большее число находится перед меньшим.
    return inv_count
 
# принимает пятнашку и возвращает количество строк, которые находятся между пустой ячейкой и нижней границей матрицы.
def findXPosition(puzzle):
    # начинаем с нижнего правого угла матрицы
    for i in range(N - 1,-1,-1):
        for j in range(N - 1,-1,-1):
            if (puzzle[i][j] == 0):
                # возвращает количество строк, которые находятся между этой ячейкой и нижней границей матрицы. 
                return N - i
 
 
#проверяет, является ли пятнашка решаемой, используя количество инверсий и позицию пустой клетки.
def isSolvable(puzzle):
    # считаем количество инверсий
    invCount = getInvCount(puzzle)
 
    #проверяем размерность (четность пазла)
    if (N & 1):
        return ~(invCount & 1)
 
    else:    # если четная 
        pos = findXPosition(puzzle)
        if (pos & 1): #если пустое поле стоит в нечетном ряду
            return ~(invCount & 1) # то возвращаем истину, если инверсий четное количество 
        else:
            return invCount & 1 #возвращаем истину если инверсий нечетное количество
puzzle =[
    [12, 1, 10, 2,],
    [7, 11, 4, 14,],
    [5, 0, 19, 15,], 
    [8, 13, 6, 3,],]
res = isSolvable(puzzle)
if res:
    print ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0])
else:
    []

                                                            Вывод

                                       Реализовал методы поиска подстроки в строке. 
                               Добавил возможность ввода строки и подстроки с клавиатуры. 
                                    Предусмотрел возможность существования пробела. 
                  Реализовал возможность выбора опции чувствительности или нечувствительности к регистру. 
Оценил время работы каждого алгоритма поиска и сравнить его со временем работы стандартной функции поиска, используемой в выбранном языке программирования
